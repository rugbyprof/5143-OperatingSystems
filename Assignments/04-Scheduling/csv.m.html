<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>csv API documentation</title>
    <meta name="description" content="CSV parsing and writing.

This module provides classes that assist in the reading and writing
of Com..." />

  <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#csv.QUOTE_ALL">QUOTE_ALL</a></li>
    <li class="mono"><a href="#csv.QUOTE_MINIMAL">QUOTE_MINIMAL</a></li>
    <li class="mono"><a href="#csv.QUOTE_NONE">QUOTE_NONE</a></li>
    <li class="mono"><a href="#csv.QUOTE_NONNUMERIC">QUOTE_NONNUMERIC</a></li>
    <li class="mono"><a href="#csv.__doc__">__doc__</a></li>
    <li class="mono"><a href="#csv.__version__">__version__</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#csv.field_size_limit">field_size_limit</a></li>
    <li class="mono"><a href="#csv.get_dialect">get_dialect</a></li>
    <li class="mono"><a href="#csv.list_dialects">list_dialects</a></li>
    <li class="mono"><a href="#csv.reader">reader</a></li>
    <li class="mono"><a href="#csv.register_dialect">register_dialect</a></li>
    <li class="mono"><a href="#csv.unregister_dialect">unregister_dialect</a></li>
    <li class="mono"><a href="#csv.writer">writer</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#csv.Dialect">Dialect</a></span>
        
          
  <ul>
    <li class="mono"><a href="#csv.Dialect.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#csv.DictReader">DictReader</a></span>
        
          
  <ul>
    <li class="mono"><a href="#csv.DictReader.__init__">__init__</a></li>
    <li class="mono"><a href="#csv.DictReader.next">next</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#csv.DictWriter">DictWriter</a></span>
        
          
  <ul>
    <li class="mono"><a href="#csv.DictWriter.__init__">__init__</a></li>
    <li class="mono"><a href="#csv.DictWriter.writeheader">writeheader</a></li>
    <li class="mono"><a href="#csv.DictWriter.writerow">writerow</a></li>
    <li class="mono"><a href="#csv.DictWriter.writerows">writerows</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#csv.Error">Error</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#csv.Sniffer">Sniffer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#csv.Sniffer.__init__">__init__</a></li>
    <li class="mono"><a href="#csv.Sniffer.has_header">has_header</a></li>
    <li class="mono"><a href="#csv.Sniffer.sniff">sniff</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#csv.excel">excel</a></span>
        
          
  <ul>
    <li class="mono"><a href="#csv.excel.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#csv.excel_tab">excel_tab</a></span>
        
          
  <ul>
    <li class="mono"><a href="#csv.excel_tab.__init__">__init__</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">csv</span> module</h1>
  <p>CSV parsing and writing.</p>
<p>This module provides classes that assist in the reading and writing
of Comma Separated Value (CSV) files, and implements the interface
described by PEP 305.  Although many CSV files are simple to parse,
the format is not formally defined by a stable specification and
is subtle enough that parsing lines of a CSV file with something
like line.split(",") is bound to fail.  The module supports three
basic APIs: reading, writing, and registration of dialects.</p>
<p>DIALECT REGISTRATION:</p>
<p>Readers and writers support a dialect argument, which is a convenient
handle on a group of settings.  When the dialect argument is a string,
it identifies one of the dialects previously registered with the module.
If it is a class or instance, the attributes of the argument are used as
the settings for the reader or writer:</p>
<pre><code>class excel:
    delimiter = ','
    quotechar = '"'
    escapechar = None
    doublequote = True
    skipinitialspace = False
    lineterminator = '\r\n'
    quoting = QUOTE_MINIMAL
</code></pre>
<p>SETTINGS:</p>
<pre><code>* quotechar - specifies a one-character string to use as the 
    quoting character.  It defaults to '"'.
* delimiter - specifies a one-character string to use as the 
    field separator.  It defaults to ','.
* skipinitialspace - specifies how to interpret whitespace which
    immediately follows a delimiter.  It defaults to False, which
    means that whitespace immediately following a delimiter is part
    of the following field.
* lineterminator -  specifies the character sequence which should 
    terminate rows.
* quoting - controls when quotes should be generated by the writer.
    It can take on any of the following module constants:

    csv.QUOTE_MINIMAL means only when required, for example, when a
        field contains either the quotechar or the delimiter
    csv.QUOTE_ALL means that quotes are always placed around fields.
    csv.QUOTE_NONNUMERIC means that quotes are always placed around
        fields which do not parse as integers or floating point
        numbers.
    csv.QUOTE_NONE means that quotes are never placed around fields.
* escapechar - specifies a one-character string used to escape 
    the delimiter when quoting is set to QUOTE_NONE.
* doublequote - controls the handling of quotes inside fields.  When
    True, two consecutive quotes are interpreted as one during read,
    and when writing, each quote character embedded in the data is
    written as two quotes
</code></pre>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv', this);">Show source &equiv;</a></p>
  <div id="source-csv" class="source">
    <pre><code>""
sv.py - read/write/investigate CSV files
""
mport re
rom functools import reduce
rom _csv import Error, __version__, writer, reader, register_dialect, \
                unregister_dialect, get_dialect, list_dialects, \
                field_size_limit, \
                QUOTE_MINIMAL, QUOTE_ALL, QUOTE_NONNUMERIC, QUOTE_NONE, \
                __doc__
rom _csv import Dialect as _Dialect
ry:
   from cStringIO import StringIO
xcept ImportError:
   from StringIO import StringIO
_all__ = [ "QUOTE_MINIMAL", "QUOTE_ALL", "QUOTE_NONNUMERIC", "QUOTE_NONE",
           "Error", "Dialect", "__doc__", "excel", "excel_tab",
           "field_size_limit", "reader", "writer",
           "register_dialect", "get_dialect", "list_dialects", "Sniffer",
           "unregister_dialect", "__version__", "DictReader", "DictWriter" ]
lass Dialect:
   """Describe an Excel dialect.
   This must be subclassed (see csv.excel).  Valid attributes are:
   delimiter, quotechar, escapechar, doublequote, skipinitialspace,
   lineterminator, quoting.
   """
   _name = ""
   _valid = False
   # placeholders
   delimiter = None
   quotechar = None
   escapechar = None
   doublequote = None
   skipinitialspace = None
   lineterminator = None
   quoting = None
   def __init__(self):
       if self.__class__ != Dialect:
           self._valid = True
       self._validate()
   def _validate(self):
       try:
           _Dialect(self)
       except TypeError, e:
           # We do this for compatibility with py2.3
           raise Error(str(e))
lass excel(Dialect):
   """Describe the usual properties of Excel-generated CSV files."""
   delimiter = ','
   quotechar = '"'
   doublequote = True
   skipinitialspace = False
   lineterminator = '\r\n'
   quoting = QUOTE_MINIMAL
egister_dialect("excel", excel)
lass excel_tab(excel):
   """Describe the usual properties of Excel-generated TAB-delimited files."""
   delimiter = '\t'
egister_dialect("excel-tab", excel_tab)
lass DictReader:
   def __init__(self, f, fieldnames=None, restkey=None, restval=None,
                dialect="excel", *args, **kwds):
       self._fieldnames = fieldnames   # list of keys for the dict
       self.restkey = restkey          # key to catch long rows
       self.restval = restval          # default value for short rows
       self.reader = reader(f, dialect, *args, **kwds)
       self.dialect = dialect
       self.line_num = 0
   def __iter__(self):
       return self
   @property
   def fieldnames(self):
       if self._fieldnames is None:
           try:
               self._fieldnames = self.reader.next()
           except StopIteration:
               pass
       self.line_num = self.reader.line_num
       return self._fieldnames
   # Issue 20004: Because DictReader is a classic class, this setter is
   # ignored.  At this point in 2.7's lifecycle, it is too late to change the
   # base class for fear of breaking working code.  If you want to change
   # fieldnames without overwriting the getter, set _fieldnames directly.
   @fieldnames.setter
   def fieldnames(self, value):
       self._fieldnames = value
   def next(self):
       if self.line_num == 0:
           # Used only for its side effect.
           self.fieldnames
       row = self.reader.next()
       self.line_num = self.reader.line_num
       # unlike the basic reader, we prefer not to return blanks,
       # because we will typically wind up with a dict full of None
       # values
       while row == []:
           row = self.reader.next()
       d = dict(zip(self.fieldnames, row))
       lf = len(self.fieldnames)
       lr = len(row)
       if lf < lr:
           d[self.restkey] = row[lf:]
       elif lf > lr:
           for key in self.fieldnames[lr:]:
               d[key] = self.restval
       return d
lass DictWriter:
   def __init__(self, f, fieldnames, restval="", extrasaction="raise",
                dialect="excel", *args, **kwds):
       self.fieldnames = fieldnames    # list of keys for the dict
       self.restval = restval          # for writing short dicts
       if extrasaction.lower() not in ("raise", "ignore"):
           raise ValueError, \
                 ("extrasaction (%s) must be 'raise' or 'ignore'" %
                  extrasaction)
       self.extrasaction = extrasaction
       self.writer = writer(f, dialect, *args, **kwds)
   def writeheader(self):
       header = dict(zip(self.fieldnames, self.fieldnames))
       self.writerow(header)
   def _dict_to_list(self, rowdict):
       if self.extrasaction == "raise":
           wrong_fields = [k for k in rowdict if k not in self.fieldnames]
           if wrong_fields:
               raise ValueError("dict contains fields not in fieldnames: "
                                + ", ".join([repr(x) for x in wrong_fields]))
       return [rowdict.get(key, self.restval) for key in self.fieldnames]
   def writerow(self, rowdict):
       return self.writer.writerow(self._dict_to_list(rowdict))
   def writerows(self, rowdicts):
       rows = []
       for rowdict in rowdicts:
           rows.append(self._dict_to_list(rowdict))
       return self.writer.writerows(rows)
 Guard Sniffer's type checking against builds that exclude complex()
ry:
   complex
xcept NameError:
   complex = float
lass Sniffer:
   '''
   "Sniffs" the format of a CSV file (i.e. delimiter, quotechar)
   Returns a Dialect object.
   '''
   def __init__(self):
       # in case there is more than one possible delimiter
       self.preferred = [',', '\t', ';', ' ', ':']
   def sniff(self, sample, delimiters=None):
       """
       Returns a dialect (or None) corresponding to the sample
       """
       quotechar, doublequote, delimiter, skipinitialspace = \
                  self._guess_quote_and_delimiter(sample, delimiters)
       if not delimiter:
           delimiter, skipinitialspace = self._guess_delimiter(sample,
                                                               delimiters)
       if not delimiter:
           raise Error, "Could not determine delimiter"
       class dialect(Dialect):
           _name = "sniffed"
           lineterminator = '\r\n'
           quoting = QUOTE_MINIMAL
           # escapechar = ''
       dialect.doublequote = doublequote
       dialect.delimiter = delimiter
       # _csv.reader won't accept a quotechar of ''
       dialect.quotechar = quotechar or '"'
       dialect.skipinitialspace = skipinitialspace
       return dialect
   def _guess_quote_and_delimiter(self, data, delimiters):
       """
       Looks for text enclosed between two identical quotes
       (the probable quotechar) which are preceded and followed
       by the same character (the probable delimiter).
       For example:
                        ,'some text',
       The quote with the most wins, same with the delimiter.
       If there is no quotechar the delimiter can't be determined
       this way.
       """
       matches = []
       for restr in ('(?P<delim>[^\w\n"\'])(?P<space> ?)(?P<quote>["\']).*?(?P=quote)(?P=delim)', # ,".*?",
                     '(?:^|\n)(?P<quote>["\']).*?(?P=quote)(?P<delim>[^\w\n"\'])(?P<space> ?)',   #  ".*?",
                     '(?P<delim>>[^\w\n"\'])(?P<space> ?)(?P<quote>["\']).*?(?P=quote)(?:$|\n)',  # ,".*?"
                     '(?:^|\n)(?P<quote>["\']).*?(?P=quote)(?:$|\n)'):                            #  ".*?" (no delim, no space)
           regexp = re.compile(restr, re.DOTALL | re.MULTILINE)
           matches = regexp.findall(data)
           if matches:
               break
       if not matches:
           # (quotechar, doublequote, delimiter, skipinitialspace)
           return ('', False, None, 0)
       quotes = {}
       delims = {}
       spaces = 0
       for m in matches:
           n = regexp.groupindex['quote'] - 1
           key = m[n]
           if key:
               quotes[key] = quotes.get(key, 0) + 1
           try:
               n = regexp.groupindex['delim'] - 1
               key = m[n]
           except KeyError:
               continue
           if key and (delimiters is None or key in delimiters):
               delims[key] = delims.get(key, 0) + 1
           try:
               n = regexp.groupindex['space'] - 1
           except KeyError:
               continue
           if m[n]:
               spaces += 1
       quotechar = reduce(lambda a, b, quotes = quotes:
                          (quotes[a] > quotes[b]) and a or b, quotes.keys())
       if delims:
           delim = reduce(lambda a, b, delims = delims:
                          (delims[a] > delims[b]) and a or b, delims.keys())
           skipinitialspace = delims[delim] == spaces
           if delim == '\n': # most likely a file with a single column
               delim = ''
       else:
           # there is *no* delimiter, it's a single column of quoted data
           delim = ''
           skipinitialspace = 0
       # if we see an extra quote between delimiters, we've got a
       # double quoted format
       dq_regexp = re.compile(
                              r"((%(delim)s)|^)\W*%(quote)s[^%(delim)s\n]*%(quote)s[^%(delim)s\n]*%(quote)s\W*((%(delim)s)|$)" % \
                              {'delim':re.escape(delim), 'quote':quotechar}, re.MULTILINE)
       if dq_regexp.search(data):
           doublequote = True
       else:
           doublequote = False
       return (quotechar, doublequote, delim, skipinitialspace)
   def _guess_delimiter(self, data, delimiters):
       """
       The delimiter /should/ occur the same number of times on
       each row. However, due to malformed data, it may not. We don't want
       an all or nothing approach, so we allow for small variations in this
       number.
         1) build a table of the frequency of each character on every line.
         2) build a table of frequencies of this frequency (meta-frequency?),
            e.g.  'x occurred 5 times in 10 rows, 6 times in 1000 rows,
            7 times in 2 rows'
         3) use the mode of the meta-frequency to determine the /expected/
            frequency for that character
         4) find out how often the character actually meets that goal
         5) the character that best meets its goal is the delimiter
       For performance reasons, the data is evaluated in chunks, so it can
       try and evaluate the smallest portion of the data possible, evaluating
       additional chunks as necessary.
       """
       data = filter(None, data.split('\n'))
       ascii = [chr(c) for c in range(127)] # 7-bit ASCII
       # build frequency tables
       chunkLength = min(10, len(data))
       iteration = 0
       charFrequency = {}
       modes = {}
       delims = {}
       start, end = 0, min(chunkLength, len(data))
       while start < len(data):
           iteration += 1
           for line in data[start:end]:
               for char in ascii:
                   metaFrequency = charFrequency.get(char, {})
                   # must count even if frequency is 0
                   freq = line.count(char)
                   # value is the mode
                   metaFrequency[freq] = metaFrequency.get(freq, 0) + 1
                   charFrequency[char] = metaFrequency
           for char in charFrequency.keys():
               items = charFrequency[char].items()
               if len(items) == 1 and items[0][0] == 0:
                   continue
               # get the mode of the frequencies
               if len(items) > 1:
                   modes[char] = reduce(lambda a, b: a[1] > b[1] and a or b,
                                        items)
                   # adjust the mode - subtract the sum of all
                   # other frequencies
                   items.remove(modes[char])
                   modes[char] = (modes[char][0], modes[char][1]
                                  - reduce(lambda a, b: (0, a[1] + b[1]),
                                           items)[1])
               else:
                   modes[char] = items[0]
           # build a list of possible delimiters
           modeList = modes.items()
           total = float(chunkLength * iteration)
           # (rows of consistent data) / (number of rows) = 100%
           consistency = 1.0
           # minimum consistency threshold
           threshold = 0.9
           while len(delims) == 0 and consistency >= threshold:
               for k, v in modeList:
                   if v[0] > 0 and v[1] > 0:
                       if ((v[1]/total) >= consistency and
                           (delimiters is None or k in delimiters)):
                           delims[k] = v
               consistency -= 0.01
           if len(delims) == 1:
               delim = delims.keys()[0]
               skipinitialspace = (data[0].count(delim) ==
                                   data[0].count("%c " % delim))
               return (delim, skipinitialspace)
           # analyze another chunkLength lines
           start = end
           end += chunkLength
       if not delims:
           return ('', 0)
       # if there's more than one, fall back to a 'preferred' list
       if len(delims) > 1:
           for d in self.preferred:
               if d in delims.keys():
                   skipinitialspace = (data[0].count(d) ==
                                       data[0].count("%c " % d))
                   return (d, skipinitialspace)
       # nothing else indicates a preference, pick the character that
       # dominates(?)
       items = [(v,k) for (k,v) in delims.items()]
       items.sort()
       delim = items[-1][1]
       skipinitialspace = (data[0].count(delim) ==
                           data[0].count("%c " % delim))
       return (delim, skipinitialspace)
   def has_header(self, sample):
       # Creates a dictionary of types of data in each column. If any
       # column is of a single type (say, integers), *except* for the first
       # row, then the first row is presumed to be labels. If the type
       # can't be determined, it is assumed to be a string in which case
       # the length of the string is the determining factor: if all of the
       # rows except for the first are the same length, it's a header.
       # Finally, a 'vote' is taken at the end for each column, adding or
       # subtracting from the likelihood of the first row being a header.
       rdr = reader(StringIO(sample), self.sniff(sample))
       header = rdr.next() # assume first row is header
       columns = len(header)
       columnTypes = {}
       for i in range(columns): columnTypes[i] = None
       checked = 0
       for row in rdr:
           # arbitrary number of rows to check, to keep it sane
           if checked > 20:
               break
           checked += 1
           if len(row) != columns:
               continue # skip rows that have irregular number of columns
           for col in columnTypes.keys():
               for thisType in [int, long, float, complex]:
                   try:
                       thisType(row[col])
                       break
                   except (ValueError, OverflowError):
                       pass
               else:
                   # fallback to length of string
                   thisType = len(row[col])
               # treat longs as ints
               if thisType == long:
                   thisType = int
               if thisType != columnTypes[col]:
                   if columnTypes[col] is None: # add new column type
                       columnTypes[col] = thisType
                   else:
                       # type is inconsistent, remove column from
                       # consideration
                       del columnTypes[col]
       # finally, compare results against first row and "vote"
       # on whether it's a header
       hasHeader = 0
       for col, colType in columnTypes.items():
           if type(colType) == type(0): # it's a length
               if len(header[col]) != colType:
                   hasHeader += 1
               else:
                   hasHeader -= 1
           else: # attempt typecast
               try:
                   colType(header[col])
               except (ValueError, TypeError):
                   hasHeader += 1
               else:
                   hasHeader -= 1
       return hasHeader > 0
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="csv.QUOTE_ALL" class="name">var <span class="ident">QUOTE_ALL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="csv.QUOTE_MINIMAL" class="name">var <span class="ident">QUOTE_MINIMAL</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="csv.QUOTE_NONE" class="name">var <span class="ident">QUOTE_NONE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="csv.QUOTE_NONNUMERIC" class="name">var <span class="ident">QUOTE_NONNUMERIC</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="csv.__doc__" class="name">var <span class="ident">__doc__</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="csv.__version__" class="name">var <span class="ident">__version__</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="csv.field_size_limit">
    <p>def <span class="ident">field_size_limit</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>Sets an upper limit on parsed fields.
    csv.field_size_limit([limit])</p>
<p>Returns old limit. If limit is not given, no new limit is set and
the old limit is returned</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="csv.get_dialect">
    <p>def <span class="ident">get_dialect</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the dialect instance associated with name.
dialect = csv.get_dialect(name)</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="csv.list_dialects">
    <p>def <span class="ident">list_dialects</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a list of all know dialect names.
names = csv.list_dialects()</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="csv.reader">
    <p>def <span class="ident">reader</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>csv_reader = reader(iterable [, dialect='excel']
                        [optional keyword args])
    for row in csv_reader:
        process(row)</p>
<p>The "iterable" argument can be any object that returns a line
of input for each iteration, such as a file object or a list.  The
optional "dialect" parameter is discussed below.  The function
also accepts optional keyword arguments which override settings
provided by the dialect.</p>
<p>The returned object is an iterator.  Each iteration returns a row
of the CSV file (which can span multiple input lines).</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="csv.register_dialect">
    <p>def <span class="ident">register_dialect</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a mapping from a string name to a dialect class.
dialect = csv.register_dialect(name, dialect)</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="csv.unregister_dialect">
    <p>def <span class="ident">unregister_dialect</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>Delete the name/dialect mapping associated with a string name.
csv.unregister_dialect(name)</p></div>
  <div class="source_cont">
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="csv.writer">
    <p>def <span class="ident">writer</span>(</p><p>...)</p>
    </div>
    

    
  
    <div class="desc"><p>csv_writer = csv.writer(fileobj [, dialect='excel']
                            [optional keyword args])
    for row in sequence:
        csv_writer.writerow(row)</p>
<pre><code>[or]

csv_writer = csv.writer(fileobj [, dialect='excel']
                        [optional keyword args])
csv_writer.writerows(rows)
</code></pre>
<p>The "fileobj" argument can be any object that supports the file API.</p></div>
  <div class="source_cont">
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="csv.Dialect" class="name">class <span class="ident">Dialect</span></p>
      
  
    <div class="desc"><p>Describe an Excel dialect.</p>
<p>This must be subclassed (see csv.excel).  Valid attributes are:
delimiter, quotechar, escapechar, doublequote, skipinitialspace,
lineterminator, quoting.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.Dialect', this);">Show source &equiv;</a></p>
  <div id="source-csv.Dialect" class="source">
    <pre><code>class Dialect:
    """Describe an Excel dialect.

    This must be subclassed (see csv.excel).  Valid attributes are:
    delimiter, quotechar, escapechar, doublequote, skipinitialspace,
    lineterminator, quoting.

    """
    _name = ""
    _valid = False
    # placeholders
    delimiter = None
    quotechar = None
    escapechar = None
    doublequote = None
    skipinitialspace = None
    lineterminator = None
    quoting = None

    def __init__(self):
        if self.__class__ != Dialect:
            self._valid = True
        self._validate()

    def _validate(self):
        try:
            _Dialect(self)
        except TypeError, e:
            # We do this for compatibility with py2.3
            raise Error(str(e))
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.Dialect">Dialect</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="csv.Dialect.delimiter" class="name">var <span class="ident">delimiter</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Dialect.doublequote" class="name">var <span class="ident">doublequote</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Dialect.escapechar" class="name">var <span class="ident">escapechar</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Dialect.lineterminator" class="name">var <span class="ident">lineterminator</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Dialect.quotechar" class="name">var <span class="ident">quotechar</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Dialect.quoting" class="name">var <span class="ident">quoting</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Dialect.skipinitialspace" class="name">var <span class="ident">skipinitialspace</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="csv.Dialect.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.Dialect.__init__', this);">Show source &equiv;</a></p>
  <div id="source-csv.Dialect.__init__" class="source">
    <pre><code>def __init__(self):
    if self.__class__ != Dialect:
        self._valid = True
    self._validate()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="csv.DictReader" class="name">class <span class="ident">DictReader</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictReader', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictReader" class="source">
    <pre><code>class DictReader:
    def __init__(self, f, fieldnames=None, restkey=None, restval=None,
                 dialect="excel", *args, **kwds):
        self._fieldnames = fieldnames   # list of keys for the dict
        self.restkey = restkey          # key to catch long rows
        self.restval = restval          # default value for short rows
        self.reader = reader(f, dialect, *args, **kwds)
        self.dialect = dialect
        self.line_num = 0

    def __iter__(self):
        return self

    @property
    def fieldnames(self):
        if self._fieldnames is None:
            try:
                self._fieldnames = self.reader.next()
            except StopIteration:
                pass
        self.line_num = self.reader.line_num
        return self._fieldnames

    # Issue 20004: Because DictReader is a classic class, this setter is
    # ignored.  At this point in 2.7's lifecycle, it is too late to change the
    # base class for fear of breaking working code.  If you want to change
    # fieldnames without overwriting the getter, set _fieldnames directly.
    @fieldnames.setter
    def fieldnames(self, value):
        self._fieldnames = value

    def next(self):
        if self.line_num == 0:
            # Used only for its side effect.
            self.fieldnames
        row = self.reader.next()
        self.line_num = self.reader.line_num

        # unlike the basic reader, we prefer not to return blanks,
        # because we will typically wind up with a dict full of None
        # values
        while row == []:
            row = self.reader.next()
        d = dict(zip(self.fieldnames, row))
        lf = len(self.fieldnames)
        lr = len(row)
        if lf < lr:
            d[self.restkey] = row[lf:]
        elif lf > lr:
            for key in self.fieldnames[lr:]:
                d[key] = self.restval
        return d
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.DictReader">DictReader</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="csv.DictReader.dialect" class="name">var <span class="ident">dialect</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictReader.fieldnames" class="name">var <span class="ident">fieldnames</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictReader.line_num" class="name">var <span class="ident">line_num</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictReader.reader" class="name">var <span class="ident">reader</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictReader.restkey" class="name">var <span class="ident">restkey</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictReader.restval" class="name">var <span class="ident">restval</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="csv.DictReader.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f, fieldnames=None, restkey=None, restval=None, dialect=&#39;excel&#39;, *args, **kwds)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictReader.__init__', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictReader.__init__" class="source">
    <pre><code>def __init__(self, f, fieldnames=None, restkey=None, restval=None,
             dialect="excel", *args, **kwds):
    self._fieldnames = fieldnames   # list of keys for the dict
    self.restkey = restkey          # key to catch long rows
    self.restval = restval          # default value for short rows
    self.reader = reader(f, dialect, *args, **kwds)
    self.dialect = dialect
    self.line_num = 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="csv.DictReader.next">
    <p>def <span class="ident">next</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictReader.next', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictReader.next" class="source">
    <pre><code>def next(self):
    if self.line_num == 0:
        # Used only for its side effect.
        self.fieldnames
    row = self.reader.next()
    self.line_num = self.reader.line_num
    # unlike the basic reader, we prefer not to return blanks,
    # because we will typically wind up with a dict full of None
    # values
    while row == []:
        row = self.reader.next()
    d = dict(zip(self.fieldnames, row))
    lf = len(self.fieldnames)
    lr = len(row)
    if lf < lr:
        d[self.restkey] = row[lf:]
    elif lf > lr:
        for key in self.fieldnames[lr:]:
            d[key] = self.restval
    return d
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="csv.DictWriter" class="name">class <span class="ident">DictWriter</span></p>
      
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictWriter', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictWriter" class="source">
    <pre><code>class DictWriter:
    def __init__(self, f, fieldnames, restval="", extrasaction="raise",
                 dialect="excel", *args, **kwds):
        self.fieldnames = fieldnames    # list of keys for the dict
        self.restval = restval          # for writing short dicts
        if extrasaction.lower() not in ("raise", "ignore"):
            raise ValueError, \
                  ("extrasaction (%s) must be 'raise' or 'ignore'" %
                   extrasaction)
        self.extrasaction = extrasaction
        self.writer = writer(f, dialect, *args, **kwds)

    def writeheader(self):
        header = dict(zip(self.fieldnames, self.fieldnames))
        self.writerow(header)

    def _dict_to_list(self, rowdict):
        if self.extrasaction == "raise":
            wrong_fields = [k for k in rowdict if k not in self.fieldnames]
            if wrong_fields:
                raise ValueError("dict contains fields not in fieldnames: "
                                 + ", ".join([repr(x) for x in wrong_fields]))
        return [rowdict.get(key, self.restval) for key in self.fieldnames]

    def writerow(self, rowdict):
        return self.writer.writerow(self._dict_to_list(rowdict))

    def writerows(self, rowdicts):
        rows = []
        for rowdict in rowdicts:
            rows.append(self._dict_to_list(rowdict))
        return self.writer.writerows(rows)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.DictWriter">DictWriter</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="csv.DictWriter.extrasaction" class="name">var <span class="ident">extrasaction</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictWriter.fieldnames" class="name">var <span class="ident">fieldnames</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictWriter.restval" class="name">var <span class="ident">restval</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.DictWriter.writer" class="name">var <span class="ident">writer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="csv.DictWriter.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, f, fieldnames, restval=&#39;&#39;, extrasaction=&#39;raise&#39;, dialect=&#39;excel&#39;, *args, **kwds)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictWriter.__init__', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictWriter.__init__" class="source">
    <pre><code>def __init__(self, f, fieldnames, restval="", extrasaction="raise",
             dialect="excel", *args, **kwds):
    self.fieldnames = fieldnames    # list of keys for the dict
    self.restval = restval          # for writing short dicts
    if extrasaction.lower() not in ("raise", "ignore"):
        raise ValueError, \
              ("extrasaction (%s) must be 'raise' or 'ignore'" %
               extrasaction)
    self.extrasaction = extrasaction
    self.writer = writer(f, dialect, *args, **kwds)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="csv.DictWriter.writeheader">
    <p>def <span class="ident">writeheader</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictWriter.writeheader', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictWriter.writeheader" class="source">
    <pre><code>def writeheader(self):
    header = dict(zip(self.fieldnames, self.fieldnames))
    self.writerow(header)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="csv.DictWriter.writerow">
    <p>def <span class="ident">writerow</span>(</p><p>self, rowdict)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictWriter.writerow', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictWriter.writerow" class="source">
    <pre><code>def writerow(self, rowdict):
    return self.writer.writerow(self._dict_to_list(rowdict))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="csv.DictWriter.writerows">
    <p>def <span class="ident">writerows</span>(</p><p>self, rowdicts)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.DictWriter.writerows', this);">Show source &equiv;</a></p>
  <div id="source-csv.DictWriter.writerows" class="source">
    <pre><code>def writerows(self, rowdicts):
    rows = []
    for rowdict in rowdicts:
        rows.append(self._dict_to_list(rowdict))
    return self.writer.writerows(rows)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="csv.Error" class="name">class <span class="ident">Error</span></p>
      
  
  <div class="source_cont">
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.Error">Error</a></li>
          <li>exceptions.Exception</li>
          <li>exceptions.BaseException</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="csv.Error.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.Error.message" class="name">var <span class="ident">message</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="csv.Sniffer" class="name">class <span class="ident">Sniffer</span></p>
      
  
    <div class="desc"><p>"Sniffs" the format of a CSV file (i.e. delimiter, quotechar)
Returns a Dialect object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.Sniffer', this);">Show source &equiv;</a></p>
  <div id="source-csv.Sniffer" class="source">
    <pre><code>class Sniffer:
    '''
    "Sniffs" the format of a CSV file (i.e. delimiter, quotechar)
    Returns a Dialect object.
    '''
    def __init__(self):
        # in case there is more than one possible delimiter
        self.preferred = [',', '\t', ';', ' ', ':']


    def sniff(self, sample, delimiters=None):
        """
        Returns a dialect (or None) corresponding to the sample
        """

        quotechar, doublequote, delimiter, skipinitialspace = \
                   self._guess_quote_and_delimiter(sample, delimiters)
        if not delimiter:
            delimiter, skipinitialspace = self._guess_delimiter(sample,
                                                                delimiters)

        if not delimiter:
            raise Error, "Could not determine delimiter"

        class dialect(Dialect):
            _name = "sniffed"
            lineterminator = '\r\n'
            quoting = QUOTE_MINIMAL
            # escapechar = ''

        dialect.doublequote = doublequote
        dialect.delimiter = delimiter
        # _csv.reader won't accept a quotechar of ''
        dialect.quotechar = quotechar or '"'
        dialect.skipinitialspace = skipinitialspace

        return dialect


    def _guess_quote_and_delimiter(self, data, delimiters):
        """
        Looks for text enclosed between two identical quotes
        (the probable quotechar) which are preceded and followed
        by the same character (the probable delimiter).
        For example:
                         ,'some text',
        The quote with the most wins, same with the delimiter.
        If there is no quotechar the delimiter can't be determined
        this way.
        """

        matches = []
        for restr in ('(?P<delim>[^\w\n"\'])(?P<space> ?)(?P<quote>["\']).*?(?P=quote)(?P=delim)', # ,".*?",
                      '(?:^|\n)(?P<quote>["\']).*?(?P=quote)(?P<delim>[^\w\n"\'])(?P<space> ?)',   #  ".*?",
                      '(?P<delim>>[^\w\n"\'])(?P<space> ?)(?P<quote>["\']).*?(?P=quote)(?:$|\n)',  # ,".*?"
                      '(?:^|\n)(?P<quote>["\']).*?(?P=quote)(?:$|\n)'):                            #  ".*?" (no delim, no space)
            regexp = re.compile(restr, re.DOTALL | re.MULTILINE)
            matches = regexp.findall(data)
            if matches:
                break

        if not matches:
            # (quotechar, doublequote, delimiter, skipinitialspace)
            return ('', False, None, 0)
        quotes = {}
        delims = {}
        spaces = 0
        for m in matches:
            n = regexp.groupindex['quote'] - 1
            key = m[n]
            if key:
                quotes[key] = quotes.get(key, 0) + 1
            try:
                n = regexp.groupindex['delim'] - 1
                key = m[n]
            except KeyError:
                continue
            if key and (delimiters is None or key in delimiters):
                delims[key] = delims.get(key, 0) + 1
            try:
                n = regexp.groupindex['space'] - 1
            except KeyError:
                continue
            if m[n]:
                spaces += 1

        quotechar = reduce(lambda a, b, quotes = quotes:
                           (quotes[a] > quotes[b]) and a or b, quotes.keys())

        if delims:
            delim = reduce(lambda a, b, delims = delims:
                           (delims[a] > delims[b]) and a or b, delims.keys())
            skipinitialspace = delims[delim] == spaces
            if delim == '\n': # most likely a file with a single column
                delim = ''
        else:
            # there is *no* delimiter, it's a single column of quoted data
            delim = ''
            skipinitialspace = 0

        # if we see an extra quote between delimiters, we've got a
        # double quoted format
        dq_regexp = re.compile(
                               r"((%(delim)s)|^)\W*%(quote)s[^%(delim)s\n]*%(quote)s[^%(delim)s\n]*%(quote)s\W*((%(delim)s)|$)" % \
                               {'delim':re.escape(delim), 'quote':quotechar}, re.MULTILINE)



        if dq_regexp.search(data):
            doublequote = True
        else:
            doublequote = False

        return (quotechar, doublequote, delim, skipinitialspace)


    def _guess_delimiter(self, data, delimiters):
        """
        The delimiter /should/ occur the same number of times on
        each row. However, due to malformed data, it may not. We don't want
        an all or nothing approach, so we allow for small variations in this
        number.
          1) build a table of the frequency of each character on every line.
          2) build a table of frequencies of this frequency (meta-frequency?),
             e.g.  'x occurred 5 times in 10 rows, 6 times in 1000 rows,
             7 times in 2 rows'
          3) use the mode of the meta-frequency to determine the /expected/
             frequency for that character
          4) find out how often the character actually meets that goal
          5) the character that best meets its goal is the delimiter
        For performance reasons, the data is evaluated in chunks, so it can
        try and evaluate the smallest portion of the data possible, evaluating
        additional chunks as necessary.
        """

        data = filter(None, data.split('\n'))

        ascii = [chr(c) for c in range(127)] # 7-bit ASCII

        # build frequency tables
        chunkLength = min(10, len(data))
        iteration = 0
        charFrequency = {}
        modes = {}
        delims = {}
        start, end = 0, min(chunkLength, len(data))
        while start < len(data):
            iteration += 1
            for line in data[start:end]:
                for char in ascii:
                    metaFrequency = charFrequency.get(char, {})
                    # must count even if frequency is 0
                    freq = line.count(char)
                    # value is the mode
                    metaFrequency[freq] = metaFrequency.get(freq, 0) + 1
                    charFrequency[char] = metaFrequency

            for char in charFrequency.keys():
                items = charFrequency[char].items()
                if len(items) == 1 and items[0][0] == 0:
                    continue
                # get the mode of the frequencies
                if len(items) > 1:
                    modes[char] = reduce(lambda a, b: a[1] > b[1] and a or b,
                                         items)
                    # adjust the mode - subtract the sum of all
                    # other frequencies
                    items.remove(modes[char])
                    modes[char] = (modes[char][0], modes[char][1]
                                   - reduce(lambda a, b: (0, a[1] + b[1]),
                                            items)[1])
                else:
                    modes[char] = items[0]

            # build a list of possible delimiters
            modeList = modes.items()
            total = float(chunkLength * iteration)
            # (rows of consistent data) / (number of rows) = 100%
            consistency = 1.0
            # minimum consistency threshold
            threshold = 0.9
            while len(delims) == 0 and consistency >= threshold:
                for k, v in modeList:
                    if v[0] > 0 and v[1] > 0:
                        if ((v[1]/total) >= consistency and
                            (delimiters is None or k in delimiters)):
                            delims[k] = v
                consistency -= 0.01

            if len(delims) == 1:
                delim = delims.keys()[0]
                skipinitialspace = (data[0].count(delim) ==
                                    data[0].count("%c " % delim))
                return (delim, skipinitialspace)

            # analyze another chunkLength lines
            start = end
            end += chunkLength

        if not delims:
            return ('', 0)

        # if there's more than one, fall back to a 'preferred' list
        if len(delims) > 1:
            for d in self.preferred:
                if d in delims.keys():
                    skipinitialspace = (data[0].count(d) ==
                                        data[0].count("%c " % d))
                    return (d, skipinitialspace)

        # nothing else indicates a preference, pick the character that
        # dominates(?)
        items = [(v,k) for (k,v) in delims.items()]
        items.sort()
        delim = items[-1][1]

        skipinitialspace = (data[0].count(delim) ==
                            data[0].count("%c " % delim))
        return (delim, skipinitialspace)


    def has_header(self, sample):
        # Creates a dictionary of types of data in each column. If any
        # column is of a single type (say, integers), *except* for the first
        # row, then the first row is presumed to be labels. If the type
        # can't be determined, it is assumed to be a string in which case
        # the length of the string is the determining factor: if all of the
        # rows except for the first are the same length, it's a header.
        # Finally, a 'vote' is taken at the end for each column, adding or
        # subtracting from the likelihood of the first row being a header.

        rdr = reader(StringIO(sample), self.sniff(sample))

        header = rdr.next() # assume first row is header

        columns = len(header)
        columnTypes = {}
        for i in range(columns): columnTypes[i] = None

        checked = 0
        for row in rdr:
            # arbitrary number of rows to check, to keep it sane
            if checked > 20:
                break
            checked += 1

            if len(row) != columns:
                continue # skip rows that have irregular number of columns

            for col in columnTypes.keys():

                for thisType in [int, long, float, complex]:
                    try:
                        thisType(row[col])
                        break
                    except (ValueError, OverflowError):
                        pass
                else:
                    # fallback to length of string
                    thisType = len(row[col])

                # treat longs as ints
                if thisType == long:
                    thisType = int

                if thisType != columnTypes[col]:
                    if columnTypes[col] is None: # add new column type
                        columnTypes[col] = thisType
                    else:
                        # type is inconsistent, remove column from
                        # consideration
                        del columnTypes[col]

        # finally, compare results against first row and "vote"
        # on whether it's a header
        hasHeader = 0
        for col, colType in columnTypes.items():
            if type(colType) == type(0): # it's a length
                if len(header[col]) != colType:
                    hasHeader += 1
                else:
                    hasHeader -= 1
            else: # attempt typecast
                try:
                    colType(header[col])
                except (ValueError, TypeError):
                    hasHeader += 1
                else:
                    hasHeader -= 1

        return hasHeader > 0
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.Sniffer">Sniffer</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="csv.Sniffer.preferred" class="name">var <span class="ident">preferred</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="csv.Sniffer.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.Sniffer.__init__', this);">Show source &equiv;</a></p>
  <div id="source-csv.Sniffer.__init__" class="source">
    <pre><code>def __init__(self):
    # in case there is more than one possible delimiter
    self.preferred = [',', '\t', ';', ' ', ':']
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="csv.Sniffer.has_header">
    <p>def <span class="ident">has_header</span>(</p><p>self, sample)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.Sniffer.has_header', this);">Show source &equiv;</a></p>
  <div id="source-csv.Sniffer.has_header" class="source">
    <pre><code>def has_header(self, sample):
    # Creates a dictionary of types of data in each column. If any
    # column is of a single type (say, integers), *except* for the first
    # row, then the first row is presumed to be labels. If the type
    # can't be determined, it is assumed to be a string in which case
    # the length of the string is the determining factor: if all of the
    # rows except for the first are the same length, it's a header.
    # Finally, a 'vote' is taken at the end for each column, adding or
    # subtracting from the likelihood of the first row being a header.
    rdr = reader(StringIO(sample), self.sniff(sample))
    header = rdr.next() # assume first row is header
    columns = len(header)
    columnTypes = {}
    for i in range(columns): columnTypes[i] = None
    checked = 0
    for row in rdr:
        # arbitrary number of rows to check, to keep it sane
        if checked > 20:
            break
        checked += 1
        if len(row) != columns:
            continue # skip rows that have irregular number of columns
        for col in columnTypes.keys():
            for thisType in [int, long, float, complex]:
                try:
                    thisType(row[col])
                    break
                except (ValueError, OverflowError):
                    pass
            else:
                # fallback to length of string
                thisType = len(row[col])
            # treat longs as ints
            if thisType == long:
                thisType = int
            if thisType != columnTypes[col]:
                if columnTypes[col] is None: # add new column type
                    columnTypes[col] = thisType
                else:
                    # type is inconsistent, remove column from
                    # consideration
                    del columnTypes[col]
    # finally, compare results against first row and "vote"
    # on whether it's a header
    hasHeader = 0
    for col, colType in columnTypes.items():
        if type(colType) == type(0): # it's a length
            if len(header[col]) != colType:
                hasHeader += 1
            else:
                hasHeader -= 1
        else: # attempt typecast
            try:
                colType(header[col])
            except (ValueError, TypeError):
                hasHeader += 1
            else:
                hasHeader -= 1
    return hasHeader > 0
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="csv.Sniffer.sniff">
    <p>def <span class="ident">sniff</span>(</p><p>self, sample, delimiters=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a dialect (or None) corresponding to the sample</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.Sniffer.sniff', this);">Show source &equiv;</a></p>
  <div id="source-csv.Sniffer.sniff" class="source">
    <pre><code>def sniff(self, sample, delimiters=None):
    """
    Returns a dialect (or None) corresponding to the sample
    """
    quotechar, doublequote, delimiter, skipinitialspace = \
               self._guess_quote_and_delimiter(sample, delimiters)
    if not delimiter:
        delimiter, skipinitialspace = self._guess_delimiter(sample,
                                                            delimiters)
    if not delimiter:
        raise Error, "Could not determine delimiter"
    class dialect(Dialect):
        _name = "sniffed"
        lineterminator = '\r\n'
        quoting = QUOTE_MINIMAL
        # escapechar = ''
    dialect.doublequote = doublequote
    dialect.delimiter = delimiter
    # _csv.reader won't accept a quotechar of ''
    dialect.quotechar = quotechar or '"'
    dialect.skipinitialspace = skipinitialspace
    return dialect
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="csv.excel" class="name">class <span class="ident">excel</span></p>
      
  
    <div class="desc"><p>Describe the usual properties of Excel-generated CSV files.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.excel', this);">Show source &equiv;</a></p>
  <div id="source-csv.excel" class="source">
    <pre><code>class excel(Dialect):
    """Describe the usual properties of Excel-generated CSV files."""
    delimiter = ','
    quotechar = '"'
    doublequote = True
    skipinitialspace = False
    lineterminator = '\r\n'
    quoting = QUOTE_MINIMAL
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.excel">excel</a></li>
          <li><a href="#csv.Dialect">Dialect</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="csv.excel.delimiter" class="name">var <span class="ident">delimiter</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.delimiter">delimiter</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel.doublequote" class="name">var <span class="ident">doublequote</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.doublequote">doublequote</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel.escapechar" class="name">var <span class="ident">escapechar</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.escapechar">escapechar</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel.lineterminator" class="name">var <span class="ident">lineterminator</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.lineterminator">lineterminator</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel.quotechar" class="name">var <span class="ident">quotechar</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.quotechar">quotechar</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel.quoting" class="name">var <span class="ident">quoting</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.quoting">quoting</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel.skipinitialspace" class="name">var <span class="ident">skipinitialspace</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.skipinitialspace">skipinitialspace</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="csv.excel.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.Dialect">Dialect</a></code>.<code><a href="#csv.Dialect.__init__">__init__</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.excel.__init__', this);">Show source &equiv;</a></p>
  <div id="source-csv.excel.__init__" class="source">
    <pre><code>def __init__(self):
    if self.__class__ != Dialect:
        self._valid = True
    self._validate()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="csv.excel_tab" class="name">class <span class="ident">excel_tab</span></p>
      
  
    <div class="desc"><p>Describe the usual properties of Excel-generated TAB-delimited files.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.excel_tab', this);">Show source &equiv;</a></p>
  <div id="source-csv.excel_tab" class="source">
    <pre><code>class excel_tab(excel):
    """Describe the usual properties of Excel-generated TAB-delimited files."""
    delimiter = '\t'
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#csv.excel_tab">excel_tab</a></li>
          <li><a href="#csv.excel">excel</a></li>
          <li><a href="#csv.Dialect">Dialect</a></li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="csv.excel_tab.delimiter" class="name">var <span class="ident">delimiter</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.delimiter">delimiter</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel_tab.doublequote" class="name">var <span class="ident">doublequote</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.doublequote">doublequote</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel_tab.escapechar" class="name">var <span class="ident">escapechar</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.escapechar">escapechar</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel_tab.lineterminator" class="name">var <span class="ident">lineterminator</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.lineterminator">lineterminator</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel_tab.quotechar" class="name">var <span class="ident">quotechar</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.quotechar">quotechar</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel_tab.quoting" class="name">var <span class="ident">quoting</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.quoting">quoting</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="csv.excel_tab.skipinitialspace" class="name">var <span class="ident">skipinitialspace</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.skipinitialspace">skipinitialspace</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="csv.excel_tab.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#csv.excel">excel</a></code>.<code><a href="#csv.excel.__init__">__init__</a></code>
    </p>

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-csv.excel_tab.__init__', this);">Show source &equiv;</a></p>
  <div id="source-csv.excel_tab.__init__" class="source">
    <pre><code>def __init__(self):
    if self.__class__ != Dialect:
        self._valid = True
    self._validate()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
